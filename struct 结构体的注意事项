1.struct 存储数据是按定义从上往下 从左至右申请存储空间。
2.结构体存储数据并不是紧挨着毫无缝隙的存储！
3.每个成员的空间会从以自己的字节大小为长度，然后偏移整数倍的长度作为自身的起始地址。也就是说如果相邻的两个成员字节长度不一致，中间会出现缝隙。
4.结构体占用总空间会按照结构体中成员长度最大的整数倍来计算（如果结构体中只有 int , double 就按 double类型 8 个字节来计算。如果只有int,char就照int
来计算）

第2点可能有些难以理解，具体一点举个例子就好懂了。
struct data
{
  int a ;
  double b ;
};
毫无疑问，由条件1知成员 a 的地址和整个结构体 data 的首地址是一致的。然后 a 为int类型一般占用 4 个字节。所以想当然的来说，如果把 data 的首地址设置为
0 的话，b应该从地址 4 开始存储，因为 a 只占 4 个字节。
但实际上 b 是从地址 8 存储的，因为它自身就占用 8 个字节 ， 所以它会从 8 的整数倍开始 ， 因为第一个 8 已经被 a 占用（实际上a只占用了一半） ， 所以它
会认为前面 8 个字节已经被占用了，所以它会占用第二个 8 字节 ，所以它的起始地址是 8 而不是 4 。

由此就衍生出一个问题.
struct 结构体中的成员存放次序是否会对其占用的空间大小产生影响。
显然结果是的。
试看下面一个例子
struct data
{
  int a ;
  int b ;
  double c ;
};

a 占用 4 个字节 ， b 发现第一个 4 字节被占用了 ， 于是本身占用第二个 4 字节。 c 发现第一个 8 字节被占用了 ( a + b 4 + 4 共 8 字节 ) 然后占用第二个
8 字节。此时我们发现空间被完美的利用了 3 个成员是紧挨着存放的。总共只占用 8*2= 16个字节存放， 其中第一个8字节存放了两个 4 字节的 int 。

struct data
{
  int a ;
  double c ;
  int b ;
};

a 依旧占用 4 个字节 ， 但是成员 c 发现第一个8字节被占用了（其实只有一半被占用，另一半是空的。但是它是按整数倍来计算，所以会将头两个 4 字节看成一个8字
节）。成员 b 发现头 16 个字节全部被占用 ， 于是它只能存储第 5 个 4 字节。可以看出就存放而言，这样的成员顺序已经浪费了 4 个字节( a 与 b 之间空了 4 
字节)。然而，实际上，计算data的实际大小的时候，它浪费的空间更多，咋看起来它只占 20 个字节（ a 占用 4 个 ，空 4 个 ， b 占用 8 个 , c 占用 4 个 ），
但实际上如果我们使用sizeof(struct data)来输出其所占字节大小时 ， 我们会发现，它占用的空间为 24 ，这是按照文章开篇的第 4 点来计算的，因为 data结构体
中，占用空间最大的类型是double类型，所以整个结构体的大小一定是 8 的整数倍。它占用了20个字节 ，按照这一要求，它的实际空间会上升的 8 的 3 倍 ，也就是
24个字节。也就是说 成员 b int 类型虽然实际上只用了 4 个字节，但是它却占用了 8 个字节，后 4 个字节并没有存储任何东西 。

写在最后，C语言为何要这样设置结构体的空间占用，我也不太清楚，至少在vc++/gcc的编译下，结构体的占用确实如此。
